
#some functions for generation useful stuff (internal use)

#register library
#a library target with given name will be created
function(register_library name)

    parseArguments(HEADERS SOURCES ARGUMENTS ${ARGN})

    #c/c++ part
    if(SOURCES)
		set(LIBRARY_NAME ${name})
		
        add_library(${LIBRARY_NAME} SHARED ${SOURCES})

        exportSymbols(${LIBRARY_NAME})
        turnOnAllWarnings(${LIBRARY_NAME})

        #install files
        if(WIN32)  # for windows (dll = runtime)
            set(RUNTIME_TYPE RUNTIME)
            set(LIB_DESTINATION ${CMAKE_INSTALL_PREFIX}/lib)
        else(WIN32)
            set(RUNTIME_TYPE LIBRARY)
            set(LIB_DESTINATION ${CMAKE_INSTALL_PREFIX}/lib${LIB_SUFFIX}/OpenLibrary)
        endif(WIN32)

        install(TARGETS ${LIBRARY_NAME} ${RUNTIME_TYPE} DESTINATION ${LIB_DESTINATION})

    endif(SOURCES)

    source_group(${LIBRARY_NAME}\\sources FILES ${SOURCES})
    source_group(${LIBRARY_NAME}\\headers FILES ${HEADERS})

    getHeadersPath(HEADERS_INSTALL_PATH)
    set(HEADERS_INSTALL_PATH ${HEADERS_INSTALL_PATH}/${name})

    install(FILES ${HEADERS}
            DESTINATION ${HEADERS_INSTALL_PATH}
            PERMISSIONS OWNER_READ GROUP_READ WORLD_READ)

    #some debug
    message("registering ${name} library")
    if(SOURCES)
        get_property(library_location TARGET ${LIBRARY_NAME} PROPERTY LOCATION)
        get_filename_component(library_file_name ${library_location} NAME)
        message("       Sources: ${SOURCES} -> ${library_file_name} -> installation path: ${LIB_DESTINATION}")

        #create variables for sub-library
        list(GET ${HEADERS} 1 header)
        generate_variables(${name} ${LIBRARY_NAME} ${library_file_name} ${HEADERS})
    endif(SOURCES)

    if(HEADERS)
        message("       Headers: ${HEADERS} installatation path: ${HEADERS_INSTALL_PATH}")
    endif(HEADERS)

endfunction(register_library)


set(AUTOGENERATED_DIR ${CMAKE_SOURCE_DIR}/autogenerated)
set(LIBRARIES_CMAKE ${AUTOGENERATED_DIR}/FindOpenLibrary.cmake)

#generate cmake variables for library
#Function generates file with library specific cmake variables
#A variable ${name}_LIBRARIES will be created.
#syntax: reguster_library_bin library_name bin1 bin2 bin3 ...
function(generate_variables name library)

    #as some unix commands are being used here - do not add anything on non unix systems
    if(UNIX)
        #convert to uppercase
        string(TOUPPER ${name} UP_NAME)

        set(output ${CMAKE_SOURCE_DIR}/autogenerated/partial/${UP_NAME})
        set(headers ${ARGN})

        #generate file with cmake variables
        add_custom_command(OUTPUT ${output}
                           COMMAND sh ARGS ${CMAKE_SOURCE_DIR}/cmake/generate_cmake_rule.sh ${UP_NAME} ${library} ${headers} > ${output}
                           DEPENDS ${CMAKE_SOURCE_DIR}/cmake/functions.cmake           #depends on this file
                           DEPENDS ${CMAKE_SOURCE_DIR}/cmake/generate_cmake_rule.sh    #and on bash script
                          )

        add_custom_target(${UP_NAME}_variables DEPENDS ${output})

        add_dependencies(FindOpenLibrary.cmake ${UP_NAME}_variables)
    endif(UNIX)

    #list used by tests
    set(OPENLIBRARY_REGISTERED_LIBRARIES
        ${output} ${OPENLIBRARY_REGISTERED_LIBRARIES}
        CACHE INTERNAL "List of CMake rule files")
        
endfunction(generate_variables)


#gather and connect all generated files with cmake variables
function(generate_variables_file)

    #as some unix commands are being used here - do not add anything on non unix systems
    if(UNIX)
        #set(dependencies ${OPENLIBRARY_REGISTERED_LIBRARY_TARGETS})

        add_custom_command(OUTPUT ${LIBRARIES_CMAKE}
                           COMMAND cat ARGS "${CMAKE_SOURCE_DIR}/src/FindOpenLibraryTemplate.cmake" > ${LIBRARIES_CMAKE}
                           COMMAND cat ARGS "${CMAKE_SOURCE_DIR}/autogenerated/partial/*" >> ${LIBRARIES_CMAKE}
                           DEPENDS ${OPENLIBRARY_REGISTERED_LIBRARIES} 
                           DEPENDS ${CMAKE_SOURCE_DIR}/src/FindOpenLibraryTemplate.cmake
                          )

        add_custom_target(FindOpenLibrary.cmake
                          DEPENDS ${LIBRARIES_CMAKE}
                         )

        #libraries.cmake is an autogenerated file, connect it to proper target
        add_dependencies(autogenerated FindOpenLibrary.cmake)
    endif(UNIX)

endfunction(generate_variables_file)


#function which creates file to by used by sublibraries to export theirs classes and functions
function(prepareExportFile filePath)

    file (WRITE ${filePath} "//OpenLibrary's automatically generated file. Do not edit.")

    #message(flag test "${MSVC}, ${MSVC_IDE}, ${MSVC60}, ${MSVC70}, ${MSVC71}, ${MSVC80}, ${CMAKE_COMPILER_2005}, ${MSVC90}, ${MSVC10} , ${CMAKE_GENERATOR}, ${WIN32}  ")

    if(CMAKE_COMPILER_IS_GNUCXX)
        file(APPEND ${filePath} "
            #ifndef OPENLIBRARY_INTERNAL_HPP
            #define OPENLIBRARY_INTERNAL_HPP

            #define OL_EXPORTS __attribute__ ((visibility (\"default\")))

            #endif
            ")
    else() #Visual Studio
        file(APPEND ${filePath} "
            #ifndef OPENLIBRARY_INTERNAL_HPP
            #define OPENLIBRARY_INTERNAL_HPP

            #ifdef OPENLIBRARY_DO_EXPORT
                #define OL_EXPORTS __declspec( dllexport )
            #else
                #define OL_EXPORTS __declspec( dllimport )
            #endif

            #endif
            ")
    endif(CMAKE_COMPILER_IS_GNUCXX)
    
    #install file
    getHeadersPath(HEADERS_INSTALL_PATH)
    install(FILES ${filePath}
            DESTINATION ${HEADERS_INSTALL_PATH}
            PERMISSIONS OWNER_READ GROUP_READ WORLD_READ)
    
endfunction(prepareExportFile)

#functions providing platform independed compiler switches
function(turnOnCpp11 target)
    if(CMAKE_COMPILER_IS_GNUCXX)
        set_target_properties(${target} PROPERTIES COMPILE_FLAGS "--std=c++11")
    else() #Visual Studio

    endif(CMAKE_COMPILER_IS_GNUCXX)
endfunction(turnOnCpp11)


function(turnOnIntelSyntax target)
    if(CMAKE_COMPILER_IS_GNUCXX)
        set_target_properties(${target} PROPERTIES COMPILE_FLAGS "-masm=intel")
    else() #Visual Studio

    endif(CMAKE_COMPILER_IS_GNUCXX)
endfunction(turnOnIntelSyntax)


function(turnOnAllWarnings target)
    if(CMAKE_COMPILER_IS_GNUCXX)
        set_target_properties(${target} PROPERTIES COMPILE_FLAGS "-W -Wall -Wextra -Winit-self -Wformat=2 -Wshadow -Wlogical-op -Wsequence-point -Wfloat-equal -Weffc++ -Wold-style-cast")
    else() #Visual Studio

    endif(CMAKE_COMPILER_IS_GNUCXX)
endfunction(turnOnAllWarnings)


function(exportSymbols target)
    if(CMAKE_COMPILER_IS_GNUCXX)
        set_target_properties(${target} PROPERTIES COMPILE_FLAGS "-fvisibility=hidden -fvisibility-inlines-hidden")
    else() #Visual Studio
        add_definitions(/DOPENLIBRARY_DO_EXPORT)
    endif(CMAKE_COMPILER_IS_GNUCXX)
endfunction(exportSymbols)


function(getHeadersPath path)
    set(${path} ${CMAKE_INSTALL_PREFIX}/include/${OPENLIBRARY_DIR_NAME} PARENT_SCOPE)
endfunction(getHeadersPath)

#usage:
#parseArguments( list of keywords_pattern ARGUMENTS list of arguments to be parsed )
#function parses list of arguments to be parsed and sets a proper keyword variables.
#
#Example: parseArguments(AAA BBB ARGUMENTS AAA a b c d e BBB f g h i j)
#will set variable AAA to a b c d e 
#     and variable BBB to f g h i j
function(parseArguments)
                
    set(arguments 0)
    set(keywords_pattern "")
    set(keywords "")
    set(var "")
    
    foreach(arg ${ARGN})
    
        if(arg STREQUAL "ARGUMENTS")
            set(arguments 1)
        else()
            
            if(arguments EQUAL 0)
                
                if(keywords_pattern STREQUAL "")
                    set(keywords_pattern "(${arg})")
                else()
                    set(keywords_pattern "${keywords_pattern}|(${arg})")
                endif(keywords_pattern STREQUAL "")
                
                set(keywords "${keywords};${arg}")
                
            else()  #arguments == 1
                
                if("${arg}" MATCHES "${keywords_pattern}" )
                    set(var ${arg})
                elseif (NOT "${var}" EQUAL "")
                    set(${var} "${${var}};${arg}")
                else()
                    message(ERROR "unknown argument: ${arg}" )
                endif ("${arg}" MATCHES "${keywords_pattern}")
                
            endif(arguments EQUAL 0)
            
        endif(arg STREQUAL "ARGUMENTS")
        
    endforeach()
    
    #export keywords
    foreach(keyword ${keywords})    
        set(${keyword} ${${keyword}} PARENT_SCOPE)    
    endforeach(keyword ${keywords})
        
endfunction(parseArguments)
